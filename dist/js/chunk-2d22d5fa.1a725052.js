(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d22d5fa"],{f6e9:function(s,n){s.exports='<h2 id="前言">前言</h2>\n<p>上一个项目<strong>android-test-front-end</strong>中，由于缺乏<strong>Vuex</strong>对状态的集中管理，导致子组件和父组件中产生了许多不必要，也不应该有的通信。同时，有些情况下，原本应该属于父组件的状态，却又决定着子组件的render，因此这部分的state应该交给<strong>Vuex</strong>来进行统一管理。使用<strong>Vuex</strong>的好处和弊端，接下来我都会一一尝试。</p>\n<h2 id="使用vuex">使用Vuex</h2>\n<h4 id="1-初步使用vuex">1. 初步使用vuex</h4>\n<p>使用<strong>Vuex</strong>的方式很简单，你可以直接下载<a href="https://unpkg.com/vuex@3.1.0/dist/vuex.js">vuex.js</a>，然后用script引入；也可以直接使用cdn的方式引入。在一个使用<strong>vue-cli</strong>打包的项目中，只需要在初始化项目的时候选择使用<strong>Vuex</strong>，脚手架会在你的项目中使用<strong>Vuex</strong>。在初始情况下，<code>src/</code>目录中会出现一个<code>store.ts</code>文件，这个文件中存放着全局的<strong>state</strong>。文件如下：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">//store.ts</span>\n<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">\'vue\'</span>;\n<span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">\'vuex\'</span>;\nVue.use(Vuex);\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store({\n    <span class="hljs-attr">state</span>: {\n    },\n    <span class="hljs-attr">mutations</span>: {\n    },\n    <span class="hljs-attr">actions</span>: {\n    },\n});</code></pre>\n<p>现在简单地添加一些属性，例如：</p>\n<pre><code class="language-javascript"><span class="hljs-comment">//store.ts</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store({\n    <span class="hljs-attr">state</span>:{\n        <span class="hljs-attr">count</span>:<span class="hljs-number">0</span>\n    },\n    <span class="hljs-attr">mutations</span>:{\n        increase(state){\n            state.count++;\n        }\n    },\n    <span class="hljs-attr">actions</span>: {\n    },\n});</code></pre>\n<blockquote class=\'warn\'>\n获取<strong>count</strong>属性时通过<code>store.state.count</code>来获取，而改变<strong>state</strong>时，不能通过<code>store.state.count++</code>来修改，而是要调用<code>stroe.commit(\'increase\')</code>来调用<strong>mutations</strong>里的函数来改变。这样做的好处是能够一眼看出哪里修改了<strong>state</strong>，同时也方便在<strong>mutations</strong>的方法中添加监听和日志。\n </blockquote>\n\n<h4 id="2-state">2. state</h4>\n<p>使用store的方法是在需要用的地方，先将<strong>store</strong>通过<strong>import</strong>的方式引入，然后直接调用。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">//someComponent.vue</span>\n<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">\'somePath\'</span>;\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">computed</span>:{\n        count(){\n            <span class="hljs-keyword">return</span> store.state.count;\n        }\n    }\n};</code></pre>\n<p>然而这种方式的弊端就是，你必须在所有需要用到<strong>全局state</strong>的地方引入<strong>store</strong>，这样使用<strong>webpack</strong>打包时，每个用到<strong>store</strong>的组件都需要将其打包进来。因此<a href="https://vuex.vuejs.org/zh/guide/state.html#%E5%9C%A8-vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%BE%97-vuex-%E7%8A%B6%E6%80%81">官方</a>给出了一个更好的方式，将<strong>store</strong>注入到vue的根节点中。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">//main.ts</span>\n<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">\'somePath\'</span>;\n<span class="hljs-keyword">new</span> Vue({\n  router,\n  store,\n  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> h(App),\n}).$mount(<span class="hljs-string">\'#app\'</span>);</code></pre>\n<p>这样一来就可以通过<code>this.$store.state.count</code>以及<code>this.$store.commit(&#39;increase&#39;)</code>来操作全局<strong>state</strong>。</p>\n<h4 id="3getter">3.getter</h4>\n<p>有时候会需要获取某个属性的<strong>计算属性</strong>，例如需要通过文章标签来筛选相应的文章。以往的处理方式是调用的地方自行处理，做的好一点就是将其抽象成一个公共函数，需要的地方就调用这个公共函数来筛选结果。不过这种做法也不是很方便，需要修改某个<strong>state</strong>的方法时，发现数据和方法不在一个文件里，这给后期的修改和维护增加了困难。因此出现了<strong>getter</strong>属性。可以将<strong>getter</strong>属性理解为<strong>类</strong>中公开暴露的<strong>方法</strong>，例如<code>getDoneTodos</code>，这样能使得数据和方法在一起，利于维护。<strong>getter</strong>有两种访问方式。</p>\n<pre><code class="language-javascript"><span class="hljs-comment">//store.ts</span>\n<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({\n  <span class="hljs-attr">state</span>: {\n    <span class="hljs-attr">todos</span>: [\n      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">\'...\'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> },\n      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">\'...\'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> }\n    ]\n  } \n})</code></pre>\n<ol>\n<li><strong>通过属性访问</strong><br>\n <strong>state</strong>作为其第一个参数：<pre><code class="language-javascript"> <span class="hljs-comment">//store.ts定义</span>\n getters: {\n     <span class="hljs-attr">getDoneTodos</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {\n         <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done) <span class="hljs-comment">//-&gt; [{ id: 1, text: \'...\', done: true}]</span>\n     }\n }\n <span class="hljs-comment">//someComponents.vue调用</span>\n store.getters.getDoneTodos <span class="hljs-comment">// -&gt; [{ id: 1, text: \'...\', done: true }]</span></code></pre>\n <strong>getters</strong>作为其第二个参数：<pre><code class="language-javascript"> <span class="hljs-comment">//store.ts定义</span>\n getters: {\n     <span class="hljs-attr">getDoneTodosCount</span>: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> {\n         <span class="hljs-keyword">return</span> getters.getDoneTodos.length <span class="hljs-comment">//参考上面的getDoneTodos</span>\n     }\n }\n <span class="hljs-comment">//someComponents.vue调用</span>\n store.getters.getDoneTodosCount <span class="hljs-comment">// -&gt; 1</span></code></pre>\n</li>\n<li><strong>通过函数访问</strong><br>\n 通过让<strong>getter</strong>返回一个函数，就能够实现传递参数给<strong>getter</strong><pre><code class="language-javascript"> <span class="hljs-comment">//store.ts定义</span>\n getters: {\n     <span class="hljs-attr">getTodosById</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span><span class="hljs-function">(<span class="hljs-params">id</span>)=&gt;</span> {\n         <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.id==id) <span class="hljs-comment">//-&gt; [{ id: 1, text: \'...\', done: true}]</span>\n     }\n }\n <span class="hljs-comment">//someComponents.vue调用</span>\n store.getters.getTodosById(<span class="hljs-number">1</span>) <span class="hljs-comment">// -&gt; [{ id: 1, text: \'...\', done: true }]</span></code></pre>\n</li>\n<li><strong>计算属性缓存</strong><br>\n当通过函数访问<strong>getter</strong>时，<strong>getter</strong>是无法缓存的；当通过属性访问时，倘若对应的<strong>state</strong>没有发生变化，类似于<strong>计算属性</strong>，它会被作为vue的一部分缓存起来，实验一下：<pre><code class="language-javascript"><span class="hljs-comment">//store.ts</span>\nmutations:{\n <span class="hljs-attr">addTodo</span>:<span class="hljs-function">(<span class="hljs-params">state: any, todo: <span class="hljs-built_in">Object</span></span>)=&gt;</span> {\n     state.todos.push(todo)\n }\n}\ngetters:{\n <span class="hljs-attr">getTodoList</span>: <span class="hljs-function">(<span class="hljs-params">state: any</span>) =&gt;</span> {\n     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'call getTodoList\'</span>)\n     <span class="hljs-keyword">return</span> state.todos\n },\n <span class="hljs-attr">getTodoListById</span>: <span class="hljs-function">(<span class="hljs-params">state: any</span>) =&gt;</span> {\n     <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">String</span></span>) =&gt;</span> {\n         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'call getTodoListById\'</span>);\n         <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function">(<span class="hljs-params">todo: any</span>) =&gt;</span> todo.id == id);\n     }\n }\n}\n<span class="hljs-comment">//someComponents.vue</span>\n<span class="hljs-keyword">this</span>.$store.getters.getTodoList <span class="hljs-comment">//-&gt;call getTodoList</span>\n<span class="hljs-keyword">this</span>.$store.getters.getTodoListById(<span class="hljs-number">1</span>) <span class="hljs-comment">//-&gt;call getTodoListById</span>\n<span class="hljs-keyword">this</span>.$store.getters.getTodoList\n<span class="hljs-keyword">this</span>.$store.getters.getTodoListById(<span class="hljs-number">1</span>) <span class="hljs-comment">//-&gt;call getTodoListById</span>\n<span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">"addTodo"</span>, { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">"..."</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> });\n<span class="hljs-keyword">this</span>.$store.getters.getTodoList <span class="hljs-comment">//-&gt;call getTodoList</span>\n<span class="hljs-keyword">this</span>.$store.getters.getTodoListById(<span class="hljs-number">1</span>) <span class="hljs-comment">//-&gt;call getTodoListById</span></code></pre>\n可以看到，即使是调用<code>getTodoListById</code>接口传入的参数一样，函数还是会被执行一次，而通过属性访问，那么<code>getTodoList</code>会被缓存起来，直到<code>todos</code>改变</li>\n</ol>\n'}}]);
//# sourceMappingURL=chunk-2d22d5fa.1a725052.js.map